// 文件API处理器

use crate::netdisk::FileItem;
use crate::server::handlers::ApiResponse;
use crate::server::AppState;
use axum::{
    extract::{Query, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use tracing::{error, info};

/// 文件列表查询参数
#[derive(Debug, Deserialize)]
pub struct FileListQuery {
    /// 目录路径
    #[serde(default = "default_dir")]
    pub dir: String,
    /// 页码
    #[serde(default = "default_page")]
    pub page: u32,
    /// 每页数量
    #[serde(default = "default_page_size")]
    pub page_size: u32,
}

fn default_dir() -> String {
    "/".to_string()
}

fn default_page() -> u32 {
    1
}

fn default_page_size() -> u32 {
    50
}

/// 文件列表响应
#[derive(Debug, Serialize)]
pub struct FileListData {
    /// 文件列表
    pub list: Vec<FileItem>,
    /// 当前目录
    pub dir: String,
    /// 页码
    pub page: u32,
    /// 当前页数量
    pub total: usize,
    /// 是否还有更多数据
    pub has_more: bool,
}

/// 获取文件列表
///
/// GET /api/v1/files?dir=/&page=1&page_size=100
pub async fn get_file_list(
    State(state): State<AppState>,
    Query(params): Query<FileListQuery>,
) -> Result<Json<ApiResponse<FileListData>>, StatusCode> {
    info!("API: 获取文件列表 dir={}, page={}", params.dir, params.page);

    // 使用单例网盘客户端
    let client_lock = state.netdisk_client.read().await;
    let client = match client_lock.as_ref() {
        Some(c) => c,
        None => {
            return Ok(Json(ApiResponse::error(
                401,
                "未登录或客户端未初始化".to_string(),
            )));
        }
    };

    // 获取文件列表
    match client
        .get_file_list(&params.dir, params.page, params.page_size)
        .await
    {
        Ok(file_list) => {
            let total = file_list.list.len();
            // 判断是否还有更多数据：如果返回的数量等于请求的 page_size，说明可能还有更多
            let has_more = total >= params.page_size as usize;
            let data = FileListData {
                list: file_list.list,
                dir: params.dir.clone(),
                page: params.page,
                total,
                has_more,
            };
            info!("成功获取 {} 个文件/文件夹, has_more={}", total, has_more);
            Ok(Json(ApiResponse::success(data)))
        }
        Err(e) => {
            error!("获取文件列表失败: {}", e);
            Ok(Json(ApiResponse::error(
                500,
                format!("获取文件列表失败: {}", e),
            )))
        }
    }
}

/// 下载链接查询参数
#[derive(Debug, Deserialize)]
pub struct DownloadUrlQuery {
    /// 文件服务器ID
    pub fs_id: u64,
    /// 文件路径（必需，用于 Locate 下载）
    pub path: String,
}

/// 下载链接响应
#[derive(Debug, Serialize)]
pub struct DownloadUrlData {
    /// 文件服务器ID
    pub fs_id: u64,
    /// 下载URL
    pub url: String,
}

/// 获取下载链接
///
/// GET /api/v1/files/download?fs_id=123456&path=/apps/test/file.zip
pub async fn get_download_url(
    State(state): State<AppState>,
    Query(params): Query<DownloadUrlQuery>,
) -> Result<Json<ApiResponse<DownloadUrlData>>, StatusCode> {
    info!(
        "API: 获取下载链接 fs_id={}, path={}",
        params.fs_id, params.path
    );

    // 使用单例网盘客户端
    let client_lock = state.netdisk_client.read().await;
    let client = match client_lock.as_ref() {
        Some(c) => c,
        None => {
            return Ok(Json(ApiResponse::error(
                401,
                "未登录或客户端未初始化".to_string(),
            )));
        }
    };

    // 获取下载链接（使用文件路径）
    // 默认使用第一个链接（索引0）
    match client.get_download_url(&params.path, 0).await {
        Ok(url) => {
            let data = DownloadUrlData {
                fs_id: params.fs_id,
                url,
            };
            info!("成功获取下载链接");
            Ok(Json(ApiResponse::success(data)))
        }
        Err(e) => {
            error!("获取下载链接失败: {}", e);
            Ok(Json(ApiResponse::error(
                500,
                format!("获取下载链接失败: {}", e),
            )))
        }
    }
}

/// 创建文件夹请求体
#[derive(Debug, Deserialize)]
pub struct CreateFolderRequest {
    /// 文件夹路径（必须以 / 开头）
    pub path: String,
}

/// 创建文件夹响应数据
#[derive(Debug, Serialize)]
pub struct CreateFolderData {
    /// 文件服务器ID
    pub fs_id: u64,
    /// 文件夹路径
    pub path: String,
    /// 是否是目录
    pub isdir: i32,
}

/// 创建文件夹
///
/// POST /api/v1/files/folder
/// Body: { "path": "/apps/test/新建文件夹" }
pub async fn create_folder(
    State(state): State<AppState>,
    Json(request): Json<CreateFolderRequest>,
) -> Result<Json<ApiResponse<CreateFolderData>>, StatusCode> {
    info!("API: 创建文件夹 path={}", request.path);

    // 验证路径格式
    if !request.path.starts_with('/') {
        return Ok(Json(ApiResponse::error(
            400,
            "路径必须以 / 开头".to_string(),
        )));
    }

    // 使用单例网盘客户端
    let client_lock = state.netdisk_client.read().await;
    let client = match client_lock.as_ref() {
        Some(c) => c,
        None => {
            return Ok(Json(ApiResponse::error(
                401,
                "未登录或客户端未初始化".to_string(),
            )));
        }
    };

    // 创建文件夹
    match client.create_folder(&request.path).await {
        Ok(response) => {
            let data = CreateFolderData {
                fs_id: response.fs_id,
                path: response.path,
                isdir: response.isdir,
            };
            info!("成功创建文件夹: fs_id={}", data.fs_id);
            Ok(Json(ApiResponse::success(data)))
        }
        Err(e) => {
            error!("创建文件夹失败: {}", e);
            Ok(Json(ApiResponse::error(
                500,
                format!("创建文件夹失败: {}", e),
            )))
        }
    }
}
